{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>TODO</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>votingsys</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>votingsys</code> to a new version will possibly break any code that was using the old version of <code>votingsys</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>votingsys</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#votingsys.utils","title":"votingsys.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#votingsys.utils.counter","title":"votingsys.utils.counter","text":"<p>Contain counter utility functions.</p>"},{"location":"refs/utils/#votingsys.utils.counter.check_non_empty_count","title":"votingsys.utils.counter.check_non_empty_count","text":"<pre><code>check_non_empty_count(counter: Counter) -&gt; None\n</code></pre> <p>Check if the counter is not empty.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter to check.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the counter is empty.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.utils.counter import check_non_empty_count\n&gt;&gt;&gt; check_non_empty_count(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.counter.check_non_negative_count","title":"votingsys.utils.counter.check_non_negative_count","text":"<pre><code>check_non_negative_count(counter: Counter) -&gt; None\n</code></pre> <p>Check if all the count values are non-negative (&gt;=0).</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter to check.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if at least one count is negative (&lt;0).</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.utils.counter import check_non_negative_count\n&gt;&gt;&gt; check_non_negative_count(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.dataframe","title":"votingsys.utils.dataframe","text":"<p>Contain DataFrame utility functions.</p>"},{"location":"refs/utils/#votingsys.utils.dataframe.check_column_exist","title":"votingsys.utils.dataframe.check_column_exist","text":"<pre><code>check_column_exist(frame: DataFrame, col: str) -&gt; None\n</code></pre> <p>Check if a column exists in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to check.</p> required <code>col</code> <code>str</code> <p>The column that should exist in the DataFrame.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the column is missing in the DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.utils.dataframe import check_column_exist\n&gt;&gt;&gt; check_column_exist(\n...     pl.DataFrame({\"a\": [0, 1, 2, 1, 0], \"b\": [1, 2, 0, 2, 1], \"c\": [2, 0, 1, 0, 2]}),\n...     col=\"a\",\n... )\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.dataframe.check_column_missing","title":"votingsys.utils.dataframe.check_column_missing","text":"<pre><code>check_column_missing(frame: DataFrame, col: str) -&gt; None\n</code></pre> <p>Check if a column is missing in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to check.</p> required <code>col</code> <code>str</code> <p>The column that should be missing in the DataFrame.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the column exists in the DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.utils.dataframe import check_column_missing\n&gt;&gt;&gt; check_column_missing(\n...     pl.DataFrame({\"a\": [0, 1, 2, 1, 0], \"b\": [1, 2, 0, 2, 1], \"c\": [2, 0, 1, 0, 2]}),\n...     col=\"col\",\n... )\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.dataframe.remove_zero_weight_rows","title":"votingsys.utils.dataframe.remove_zero_weight_rows","text":"<pre><code>remove_zero_weight_rows(\n    frame: DataFrame, weight_col: str\n) -&gt; DataFrame\n</code></pre> <p>Remove all rows from a DataFrame where the weight value is zero.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame from which rows should be filtered.</p> required <code>weight_col</code> <code>str</code> <p>The name of the column that contains the weight values.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A new DataFrame with all rows removed where the weight is zero.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>weight_col</code> does not exist in the DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.utils.dataframe import remove_zero_weight_rows\n&gt;&gt;&gt; out = remove_zero_weight_rows(\n...     pl.DataFrame(\n...         {\n...             \"a\": [0, 1, 2, 0, 1, 2],\n...             \"b\": [1, 2, 0, 1, 2, 0],\n...             \"c\": [2, 0, 1, 2, 0, 1],\n...             \"weight\": [3, 0, 2, 1, 2, 0],\n...         }\n...     ),\n...     weight_col=\"weight\",\n... )\n&gt;&gt;&gt; out\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2506 weight \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---    \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 1   \u2506 2   \u2506 3      \u2502\n\u2502 2   \u2506 0   \u2506 1   \u2506 2      \u2502\n\u2502 0   \u2506 1   \u2506 2   \u2506 1      \u2502\n\u2502 1   \u2506 2   \u2506 0   \u2506 2      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.dataframe.sum_weights_by_group","title":"votingsys.utils.dataframe.sum_weights_by_group","text":"<pre><code>sum_weights_by_group(\n    frame: DataFrame, weight_col: str\n) -&gt; DataFrame\n</code></pre> <p>Aggregate a DataFrame by summing the weight values for rows with identical values in all columns except the weight column.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame to aggregate.</p> required <code>weight_col</code> <code>str</code> <p>The name of the column that contains the weight values to be summed.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A new DataFrame with rows grouped by all non-weight columns,</p> <code>DataFrame</code> <p>and the weight column summed within each group.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>weight_col</code> does not exist in the DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.utils.dataframe import sum_weights_by_group\n&gt;&gt;&gt; out = sum_weights_by_group(\n...     pl.DataFrame(\n...         {\n...             \"a\": [0, 1, 2, 0, 1, 2],\n...             \"b\": [1, 2, 0, 1, 2, 0],\n...             \"c\": [2, 0, 1, 2, 0, 1],\n...             \"weight\": [3, 5, 2, 1, 2, -2],\n...         }\n...     ),\n...     weight_col=\"weight\",\n... )\n&gt;&gt;&gt; out.sort(\"weight\", descending=True)\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2506 weight \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---    \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2506 0   \u2506 7      \u2502\n\u2502 0   \u2506 1   \u2506 2   \u2506 4      \u2502\n\u2502 2   \u2506 0   \u2506 1   \u2506 0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.dataframe.value_count","title":"votingsys.utils.dataframe.value_count","text":"<pre><code>value_count(frame: DataFrame, value: Any) -&gt; dict[str, int]\n</code></pre> <p>Count the occurrences of a given value in each column of a DataFrame.</p> <p>This function computes how many times a specified value appears in each column. Null values are ignored during the counting process.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame.</p> required <code>value</code> <code>Any</code> <p>The value to count in each column.</p> required <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>A dictionary mapping each column name to the number of times the specified value appears.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified value is <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.utils.dataframe import value_count\n&gt;&gt;&gt; counts = value_count(\n...     pl.DataFrame({\"a\": [0, 1, 2, 1, 0], \"b\": [1, 2, 0, 2, 1], \"c\": [2, 0, 1, 0, 2]}),\n...     value=1,\n... )\n&gt;&gt;&gt; counts\n{'a': 2, 'b': 2, 'c': 1}\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.dataframe.weighted_value_count","title":"votingsys.utils.dataframe.weighted_value_count","text":"<pre><code>weighted_value_count(\n    frame: DataFrame, value: int, weight_col: str\n) -&gt; dict[str, int | float]\n</code></pre> <p>Count the weighted occurrences of a given value in each column of a DataFrame.</p> <p>This function computes how many times a specified value appears in each column, weighted by the values in a separate count column. Null values are ignored during the counting process.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame.</p> required <code>value</code> <code>int</code> <p>The value to count in each column.</p> required <code>weight_col</code> <code>str</code> <p>The name of the column that holds the weight for each row.</p> required <p>Returns:</p> Type Description <code>dict[str, int | float]</code> <p>A dictionary mapping each column name (excluding the count column) to the weighted number of times the specified value appears.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the weight column is missing in the DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.utils.dataframe import weighted_value_count\n&gt;&gt;&gt; counts = weighted_value_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 5, 2]}),\n...     value=1,\n...     weight_col=\"count\",\n... )\n&gt;&gt;&gt; counts\n{'a': 5, 'b': 3, 'c': 2}\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.mapping","title":"votingsys.utils.mapping","text":"<p>Contain mapping utility functions.</p>"},{"location":"refs/utils/#votingsys.utils.mapping.find_max_in_mapping","title":"votingsys.utils.mapping.find_max_in_mapping","text":"<pre><code>find_max_in_mapping(\n    mapping: Mapping[str, float],\n) -&gt; tuple[tuple[str, ...], float]\n</code></pre> <p>Find the maximum value in a mapping and returns the corresponding key(s) and the value.</p> <p>If multiple keys have the same maximum value, all such keys are returned in a list.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[str, float]</code> <p>A mapping from keys to numeric values.</p> required <p>Returns:</p> Type Description <code>tuple[tuple[str, ...], float]</code> <p>A tuple containing the tuple of keys with the maximum value and the maximum value itself.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the mapping is empty.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.utils.mapping import find_max_in_mapping\n&gt;&gt;&gt; out = find_max_in_mapping({\"x\": 3, \"y\": 1})\n&gt;&gt;&gt; out\n(('x',), 3)\n&gt;&gt;&gt; out = find_max_in_mapping({\"a\": 10, \"b\": 20, \"c\": 20})\n&gt;&gt;&gt; out\n(('b', 'c'), 20)\n</code></pre>"},{"location":"refs/utils/#votingsys.utils.timing","title":"votingsys.utils.timing","text":"<p>Contain utility functions to measure time.</p>"},{"location":"refs/utils/#votingsys.utils.timing.timeblock","title":"votingsys.utils.timing.timeblock","text":"<pre><code>timeblock(\n    message: str = \"Total time: {time}\",\n) -&gt; Generator[None]\n</code></pre> <p>Implement a context manager to measure the execution time of a block of code.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message displayed when the time is logged.</p> <code>'Total time: {time}'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from votingsys.utils.timing import timeblock\n&gt;&gt;&gt; with timeblock():\n...     x = [1, 2, 3]\n...\n&gt;&gt;&gt; with timeblock(\"Training: {time}\"):\n...     y = [1, 2, 3]\n...\n</code></pre>"},{"location":"refs/vote/","title":"Vote","text":""},{"location":"refs/vote/#votingsys.vote","title":"votingsys.vote","text":"<p>Contain the vote implementations.</p>"},{"location":"refs/vote/#votingsys.vote.BaseVote","title":"votingsys.vote.BaseVote","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a vote.</p>"},{"location":"refs/vote/#votingsys.vote.BaseVote.equal","title":"votingsys.vote.BaseVote.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two vote objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two votes are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; obj1 = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; obj2 = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; obj3 = SingleMarkVote(Counter({\"a\": 10, \"b\": 2}))\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.BaseVote.get_num_candidates","title":"votingsys.vote.BaseVote.get_num_candidates  <code>abstractmethod</code>","text":"<pre><code>get_num_candidates() -&gt; int\n</code></pre> <p>Return the number of candidates.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of candidates.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; vote.get_num_candidates()\n4\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.BaseVote.get_num_voters","title":"votingsys.vote.BaseVote.get_num_voters  <code>abstractmethod</code>","text":"<pre><code>get_num_voters() -&gt; int\n</code></pre> <p>Return the number of voters.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of voters.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; vote.get_num_voters()\n20\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.MultipleWinnersFoundError","title":"votingsys.vote.MultipleWinnersFoundError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when multiple winners are found instead of one.</p>"},{"location":"refs/vote/#votingsys.vote.RankedVote","title":"votingsys.vote.RankedVote","text":"<p>               Bases: <code>BaseVote</code></p> <p>Define the ranked vote.</p> <p>A ranked vote, also known as a preferential vote, is a voting system in which voters rank candidates or options in order of preference, rather than choosing just one.</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>DataFrame</code> <p>A DataFrame with the ranking for each voter. Each column represents a candidate, and each row is a voter ranking. The ranking goes from <code>0</code> to <code>n-1</code>, where <code>n</code> is the number of candidates. One column contains the number of voters for this ranking.</p> required <code>count_col</code> <code>str</code> <p>The column with the count data for each ranking.</p> <code>'count'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 5, 2]})\n... )\n&gt;&gt;&gt; vote\nRankedVote(num_candidates=3, num_voters=10, count_col='count')\n&gt;&gt;&gt; vote.ranking\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2506 count \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 1   \u2506 2   \u2506 3     \u2502\n\u2502 1   \u2506 2   \u2506 0   \u2506 5     \u2502\n\u2502 2   \u2506 0   \u2506 1   \u2506 2     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.ranking","title":"votingsys.vote.RankedVote.ranking  <code>property</code>","text":"<pre><code>ranking: DataFrame\n</code></pre> <p>Return the DataFrame containing the rankings.</p>"},{"location":"refs/vote/#votingsys.vote.RankedVote.absolute_majority_winner","title":"votingsys.vote.RankedVote.absolute_majority_winner","text":"<pre><code>absolute_majority_winner() -&gt; str\n</code></pre> <p>Compute the winner based on the absolute majority rule.</p> <p>The candidate receiving more than 50% of the vote is the winner.</p> <p>Returns:</p> Type Description <code>str</code> <p>The winner based on the absolute majority rule.</p> <p>Raises:</p> Type Description <code>WinnerNotFoundError</code> <p>if no candidate has the majority of votes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 6, 2]}),\n... )\n&gt;&gt;&gt; vote.absolute_majority_winner()\n'c'\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.borda_count_winner","title":"votingsys.vote.RankedVote.borda_count_winner","text":"<pre><code>borda_count_winner(points: Sequence | None = None) -&gt; str\n</code></pre> <p>Compute the winner based on the Borda count rule.</p> <p>The Borda count method is a ranked voting system where voters list candidates in order of preference. Points are assigned based on position in each ranking. For example, in an election with n candidates, a first-place vote earns n points, second place gets n-1, and so on, down to 1. The candidate with the highest total score across all votes wins. This method considers the overall preferences of voters, not just their top choices.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>Sequence | None</code> <p>The points associated for each rank. The first value is the point for rank 0, the second value is the point for rank 1, etc. The number of points must be equal to the number of candidates. If no points is given, the default points are <code>[n, n-1, n-2, ..., 1]</code></p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The winner based on the Borda count rule.</p> <p>Raises:</p> Type Description <code>MultipleWinnersFoundError</code> <p>if the leading candidates are tied.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 5, 2]}),\n... )\n&gt;&gt;&gt; vote.borda_count_winner()\n'c'\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.borda_count_winners","title":"votingsys.vote.RankedVote.borda_count_winners","text":"<pre><code>borda_count_winners(\n    points: Sequence | None = None,\n) -&gt; tuple[str, ...]\n</code></pre> <p>Compute the winner(s) based on the Borda count rule.</p> <p>The Borda count method is a ranked voting system where voters list candidates in order of preference. Points are assigned based on position in each ranking. For example, in an election with n candidates, a first-place vote earns n points, second place gets n-1, and so on, down to 1. The candidate with the highest total score across all votes wins. This method considers the overall preferences of voters, not just their top choices.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>Sequence | None</code> <p>The points associated for each rank. The first value is the point for rank 0, the second value is the point for rank 1, etc. The number of points must be equal to the number of candidates. If no points is given, the default points are <code>[n, n-1, n-2, ..., 1]</code></p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The winners based on the Borda count rule. Multiple winners can be returned if the leading candidates are tied. The candiates are sorted by alphabetical order.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 5, 2]}),\n... )\n&gt;&gt;&gt; vote.borda_count_winners()\n('c',)\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 0, 2], \"c\": [2, 0, 1], \"count\": [1, 1, 1]}),\n... )\n&gt;&gt;&gt; vote.borda_count_winners(points=[4, 2, 1])\n('a', 'b', 'c')\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.borda_counts","title":"votingsys.vote.RankedVote.borda_counts","text":"<pre><code>borda_counts(\n    points: Sequence | None = None,\n) -&gt; dict[str, float]\n</code></pre> <p>Compute the Borda count for each candidate.</p> <p>The Borda count method is a ranked voting system where voters list candidates in order of preference. Points are assigned based on position in each ranking. For example, in an election with n candidates, a first-place vote earns n points, second place gets n-1, and so on, down to 1. The candidate with the highest total score across all votes wins. This method considers the overall preferences of voters, not just their top choices.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>Sequence | None</code> <p>The points associated for each rank. The first value is the point for rank 0, the second value is the point for rank 1, etc. The number of points must be equal to the number of candidates. If no points is given, the default points are <code>[n, n-1, n-2, ..., 1]</code></p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>A dictionary with the Borda count for each candidate. The key is the candidate and the value is the Borda count.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 5, 2]}),\n... )\n&gt;&gt;&gt; vote.borda_counts()\n{'a': 21.0, 'b': 17.0, 'c': 22.0}\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.from_dataframe","title":"votingsys.vote.RankedVote.from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(\n    ranking: DataFrame, count_col: str = \"count\"\n) -&gt; RankedVote\n</code></pre> <p>Instantiate a <code>RankedVote</code> object from a <code>polars.DataFrame</code> containing the ranking.</p> <p>Internally, <code>RankedVote</code> uses a compressed DataFrame with the number of occurrences for each ranking. For example if the same ranking is <code>N</code> times in the DataFrame, it will be re-encoded as a single row with a count of <code>N</code>. The \"compressed\" representation is more efficient because the new DataFrame can be much smaller.</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>DataFrame</code> <p>The DataFrame with the ranking for each voter.</p> required <code>count_col</code> <code>str</code> <p>The column that will contain the count values for each ranking.</p> <code>'count'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe(\n...     pl.DataFrame(\n...         {\"a\": [0, 1, 2, 1, 0, 0], \"b\": [1, 2, 0, 2, 1, 1], \"c\": [2, 0, 1, 0, 2, 2]}\n...     )\n... )\n&gt;&gt;&gt; vote\nRankedVote(num_candidates=3, num_voters=6, count_col='count')\n&gt;&gt;&gt; vote.ranking\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2506 count \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 1   \u2506 2   \u2506 3     \u2502\n\u2502 1   \u2506 2   \u2506 0   \u2506 2     \u2502\n\u2502 2   \u2506 0   \u2506 1   \u2506 1     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.from_dataframe_with_count","title":"votingsys.vote.RankedVote.from_dataframe_with_count  <code>classmethod</code>","text":"<pre><code>from_dataframe_with_count(\n    ranking: DataFrame, count_col: str = \"count\"\n) -&gt; RankedVote\n</code></pre> <p>Instantiate a <code>RankedVote</code> object from a <code>polars.DataFrame</code> containing the rankings and their associated counts.</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>DataFrame</code> <p>A DataFrame with the ranking for each voters. Each column represents a candidate, and each row is a voter ranking. The ranking goes from <code>0</code> to <code>n-1</code>, where <code>n</code> is the number of candidates. One column contains the number of voters for this ranking.</p> required <code>count_col</code> <code>str</code> <p>The column with the count data for each ranking.</p> <code>'count'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame(\n...         {\n...             \"a\": [0, 1, 2, 0, 2],\n...             \"b\": [1, 2, 0, 1, 1],\n...             \"c\": [2, 0, 1, 2, 0],\n...             \"count\": [3, 5, 2, 1, 0],\n...         }\n...     ),\n... )\n&gt;&gt;&gt; vote\nRankedVote(num_candidates=3, num_voters=11, count_col='count')\n&gt;&gt;&gt; vote.ranking\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2506 count \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2506 0   \u2506 5     \u2502\n\u2502 0   \u2506 1   \u2506 2   \u2506 4     \u2502\n\u2502 2   \u2506 0   \u2506 1   \u2506 2     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.plurality_counts","title":"votingsys.vote.RankedVote.plurality_counts","text":"<pre><code>plurality_counts() -&gt; dict[str, int]\n</code></pre> <p>Compute the plurality count for each candidate, i.e. the number of voters who rank each candidate in first place.</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>A dictionary with the count of votes for each candidate. The key is the candidate and the value is the number of votes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 6, 2]}),\n... )\n&gt;&gt;&gt; vote.plurality_counts()\n{'a': 3, 'b': 2, 'c': 6}\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.plurality_winner","title":"votingsys.vote.RankedVote.plurality_winner","text":"<pre><code>plurality_winner() -&gt; str\n</code></pre> <p>Compute the winner based on the plurality rule.</p> <p>This rule is also named First-Past-The-Post (FPTP). The leading candidate, whether or not they have a majority of votes, is the winner.</p> <p>Returns:</p> Type Description <code>str</code> <p>The winner based on the plurality rule.</p> <p>Raises:</p> Type Description <code>MultipleWinnersFoundError</code> <p>if the leading candidates are tied.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 6, 2]}),\n... )\n&gt;&gt;&gt; vote.plurality_winner()\n'c'\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.RankedVote.plurality_winners","title":"votingsys.vote.RankedVote.plurality_winners","text":"<pre><code>plurality_winners() -&gt; tuple[str, ...]\n</code></pre> <p>Compute the winner(s) based on the plurality rule.</p> <p>This rule is also named First-Past-The-Post (FPTP). The leading candidate, whether or not they have a majority of votes, is the winner.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The winners based on the plurality rule. Multiple winners can be returned if the leading candidates are tied. The candiates are sorted by alphabetical order.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import RankedVote\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame({\"a\": [0, 1, 2], \"b\": [1, 2, 0], \"c\": [2, 0, 1], \"count\": [3, 6, 2]}),\n... )\n&gt;&gt;&gt; vote.plurality_winners()\n('c',)\n&gt;&gt;&gt; vote = RankedVote.from_dataframe_with_count(\n...     pl.DataFrame(\n...         {\"a\": [0, 1, 2, 1], \"b\": [1, 2, 0, 0], \"c\": [2, 0, 1, 2], \"count\": [3, 6, 2, 4]}\n...     ),\n... )\n&gt;&gt;&gt; vote.plurality_winners()\n('b', 'c')\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote","title":"votingsys.vote.SingleMarkVote","text":"<p>               Bases: <code>BaseVote</code></p> <p>Define a single-mark vote.</p> <p>This vote assumes that the voter must mark one and only one candidate.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter with the number of votes for each candidate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if at least one count is negative (&lt;0).</p> <code>ValueError</code> <p>if the counter is empty.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; vote\nSingleMarkVote(\n  (counter): Counter({'a': 10, 'c': 5, 'd': 3, 'b': 2})\n)\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote.absolute_majority_winner","title":"votingsys.vote.SingleMarkVote.absolute_majority_winner","text":"<pre><code>absolute_majority_winner() -&gt; str\n</code></pre> <p>Compute the winner based on the absolute majority rule.</p> <p>The candidate receiving more than 50% of the vote is the winner.</p> <p>Returns:</p> Type Description <code>str</code> <p>The winner based on the absolute majority rule.</p> <p>Raises:</p> Type Description <code>WinnerNotFoundError</code> <p>if no candidate has the majority of votes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 20, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; vote.absolute_majority_winner()\n'b'\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote.from_dataframe","title":"votingsys.vote.SingleMarkVote.from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(\n    frame: DataFrame,\n    choice_col: str,\n    count_col: str | None = None,\n) -&gt; SingleMarkVote\n</code></pre> <p>Instantiate a <code>SingleMarkVote</code> object from a <code>polars.DataFrame</code> containing the choices.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame containing the choices.</p> required <code>choice_col</code> <code>str</code> <p>The column containing the choices.</p> required <code>count_col</code> <code>str | None</code> <p>The column containing the count for each choice. If <code>None</code>, it assumes the count for each choice is 1.</p> <code>None</code> <p>Returns:</p> Type Description <code>SingleMarkVote</code> <p>The instantiated <code>SingleMarkVote</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; # Example without count column\n&gt;&gt;&gt; vote = SingleMarkVote.from_dataframe(\n...     pl.DataFrame({\"first_choice\": [\"a\", \"b\", \"a\", \"c\", \"a\", \"a\", \"b\"]}),\n...     choice_col=\"first_choice\",\n... )\n&gt;&gt;&gt; vote\nSingleMarkVote(\n  (counter): Counter({'a': 4, 'b': 2, 'c': 1})\n)\n&gt;&gt;&gt; # Example with count column\n&gt;&gt;&gt; vote = SingleMarkVote.from_dataframe(\n...     pl.DataFrame(\n...         {\n...             \"first_choice\": [\"a\", \"b\", \"a\", \"c\", \"a\", \"a\", \"b\"],\n...             \"count\": [3, 3, 5, 2, 2, 6, 1],\n...         }\n...     ),\n...     choice_col=\"first_choice\",\n...     count_col=\"count\",\n... )\n&gt;&gt;&gt; vote\nSingleMarkVote(\n  (counter): Counter({'a': 16, 'b': 4, 'c': 2})\n)\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote.from_sequence","title":"votingsys.vote.SingleMarkVote.from_sequence  <code>classmethod</code>","text":"<pre><code>from_sequence(votes: Sequence[str]) -&gt; SingleMarkVote\n</code></pre> <p>Instantiate a <code>SingleMarkVote</code> object from the sequence of votes.</p> <p>Parameters:</p> Name Type Description Default <code>votes</code> <code>Sequence[str]</code> <p>The sequence of votes.</p> required <p>Returns:</p> Type Description <code>SingleMarkVote</code> <p>The instantiated <code>SingleMarkVote</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote.from_sequence([\"a\", \"b\", \"a\", \"c\", \"a\", \"a\", \"b\"])\n&gt;&gt;&gt; vote\nSingleMarkVote(\n  (counter): Counter({'a': 4, 'b': 2, 'c': 1})\n)\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote.from_series","title":"votingsys.vote.SingleMarkVote.from_series  <code>classmethod</code>","text":"<pre><code>from_series(choices: Series) -&gt; SingleMarkVote\n</code></pre> <p>Instantiate a <code>SingleMarkVote</code> object from a <code>polars.Series</code> containing the choices.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>Series</code> <p>The <code>polars.Series</code> containing the choices.</p> required <p>Returns:</p> Type Description <code>SingleMarkVote</code> <p>The instantiated <code>SingleMarkVote</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote.from_series(pl.Series([\"a\", \"b\", \"a\", \"c\", \"a\", \"a\", \"b\"]))\n&gt;&gt;&gt; vote\nSingleMarkVote(\n  (counter): Counter({'a': 4, 'b': 2, 'c': 1})\n)\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote.plurality_counts","title":"votingsys.vote.SingleMarkVote.plurality_counts","text":"<pre><code>plurality_counts() -&gt; dict[str, int]\n</code></pre> <p>Compute the number of votes for each candidate.</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>A dictionary with the number of votes for each candidate. The key is the candidate and the value is the number of votes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; vote.plurality_counts()\n{'a': 10, 'b': 2, 'c': 5, 'd': 3}\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote.plurality_winner","title":"votingsys.vote.SingleMarkVote.plurality_winner","text":"<pre><code>plurality_winner() -&gt; str\n</code></pre> <p>Compute the winner based on the plurality rule.</p> <p>This rule is also named First-Past-The-Post (FPTP). The leading candidate, whether or not they have a majority of votes, is the winner.</p> <p>Returns:</p> Type Description <code>str</code> <p>The winner based on the plurality rule.</p> <p>Raises:</p> Type Description <code>MultipleWinnersFoundError</code> <p>if the leading candidates are tied.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; vote.plurality_winner()\n'a'\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote.plurality_winners","title":"votingsys.vote.SingleMarkVote.plurality_winners","text":"<pre><code>plurality_winners() -&gt; tuple[str, ...]\n</code></pre> <p>Compute the winner(s) based on the plurality rule.</p> <p>This rule is also named First-Past-The-Post (FPTP). The leading candidate, whether or not they have a majority of votes, is the winner.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The winners based on the plurality rule. Multiple winners can be returned if the leading candidates are tied. The candiates are sorted by alphabetical order.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; vote.plurality_winners()\n('a',)\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 2, \"c\": 5, \"d\": 10}))\n&gt;&gt;&gt; vote.plurality_winners()\n('a', 'd')\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.SingleMarkVote.super_majority_winner","title":"votingsys.vote.SingleMarkVote.super_majority_winner","text":"<pre><code>super_majority_winner(threshold: float) -&gt; str\n</code></pre> <p>Compute the winner based on the super majority rule.</p> <p>The candidate receiving more than X% of the vote is the winner, where <code>X &gt; 0.5</code>.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>The minimal threshold to find the super majority winner.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The winner based on the super majority rule.</p> <p>Raises:</p> Type Description <code>WinnerNotFoundError</code> <p>if no candidate has the super majority of votes.</p> <code>ValueError</code> <p>if the threshold is not valid.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from votingsys.vote import SingleMarkVote\n&gt;&gt;&gt; vote = SingleMarkVote(Counter({\"a\": 10, \"b\": 30, \"c\": 5, \"d\": 3}))\n&gt;&gt;&gt; vote.super_majority_winner(0.6)\n'b'\n</code></pre>"},{"location":"refs/vote/#votingsys.vote.WinnerNotFoundError","title":"votingsys.vote.WinnerNotFoundError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when no winner can be found.</p>"}]}